component provides HiddenLayer requires io.Output out, data.DecUtil decUtil, data.IntUtil intUtil, data.StringUtil strUtil{

  int maxNeurons = 10
  int numNeurons = 3
  int numColumns = 10
  int numWeights = 100

  transfer dec currentWeights[100]
  transfer dec adaptedWeights[100]

  dec[] HiddenLayer:fowardPropagation(dec inputValues[], dec weights[])
  {
    currentWeights = weights

    int previousNumNeurons = getNumNeurons(inputValues)
    adaptedWeights = adaptWeights(currentWeights, previousNumNeurons, numNeurons)
    dec activatedNeurons[] = activation(inputValues,adaptedWeights)

    return activatedNeurons
  }
  dec[] HiddenLayer:backPropagation(dec alpha, dec delta, dec h[], dec previousWeights[])
  {
    int previousNumNeurons = getNumNeurons(h)
    adaptedWeights = adaptWeights(currentWeights, previousNumNeurons, numNeurons)

      dec h_t[] = matrix_transpose(h)
      dec aux1[] = matrix_mul(previousWeights,h)
      dec aux2[] = matrix_scalar_mul(delta,aux1)
      dec aux3[] = matrix_scalar_mul(alpha,aux2)
      dec newWeights[] = matrix_sub(adaptedWeights, aux3)

      return newWeights

  }
  dec[] getWeights(){
    return adaptedWeights
  }
  int getNumNeurons(dec inputValues[]){
    int count = 0
    for (int i=0; i < numColumns; i++){
      for (int j=0; j < numColumns; j++){
        int index = i*numColumns+j
        if (inputValues[index] != 0)
          count = count+1
      }
    }
    return count
  }
  dec[] convertWeights(char string[]){
    dec weights[100]
    String array[] = strUtil.explode(string, "\t")
    for (int i = 0; i < array.arrayLength; i++){
       weights[i] = decUtil.decFromString(array[i].string)
    }
    return weights
  }
  dec[] adaptWeights(dec weights[], int pNeurons, int cNeurons){
    for (int i=0; i < numColumns; i++){
      for (int j=0; j < numColumns; j++){
        int index = i*numColumns+j
        if (i>=pNeurons)
          weights[index] = 0
        if (j>=cNeurons)
          weights[index] = 0
      }
    }
    return weights
  }
  void printWeights(dec weights[]){
    for (int i=0; i < numColumns; i++){
      for (int j=0; j < numColumns; j++){
        int index = i*numColumns+j
        out.print("$(decUtil.decToString(weights[index])) ")
      }
      out.print("\n")
    }
  }
  void printNeurons(dec values[]){
    for (int i=0; i < values.arrayLength; i++){
      out.print("$(decUtil.decToString(values[i])) ")
    }
  }
  dec[] convertInput(dec values[]){
    dec newInput[100]
    for (int i =0; i < numNeurons; i++){
      newInput[i] = values[i]
    }
    for (int i =numNeurons; i < maxNeurons; i++){
      newInput[i] = 0
    }
    return newInput
  }
  dec[] activation(dec inputValues[], dec layerWeights[]){
    dec sum = 0.0
    dec multiply[100]
    // rows of first matrix
    for (int c = 0; c < numColumns; c++) {
      // columns of second matrix
     for (int d = 0; d < numColumns; d++) {
       //  rows of second matrix
       for (int k = 0; k < numColumns; k++) {
         int indexFirst = c*numColumns+k
         int indexSecond = k*numColumns+d
         sum = sum + inputValues[indexFirst]*layerWeights[indexSecond]
       }
       int indexThird = c*numColumns+d
       multiply[indexThird] = sum
       sum = 0
     }
   }
   return multiply
  }
  dec[] matrix_scalar_mul(dec a, dec matrix_b[]){
    dec result[100]
    for (int c = 0; c < numColumns; c++) {
     for (int d = 0; d < numColumns; d++) {
         int index = c*numColumns+d
         result[index] = a*matrix_b[index]
       }
   }
   return result
  }

  dec[] matrix_mul(dec matrix_a[], dec matrix_b[]){
    dec sum = 0.0
    dec multiply[100]
    // rows of first matrix
    for (int c = 0; c < numColumns; c++) {
      // columns of second matrix
     for (int d = 0; d < numColumns; d++) {
       //  rows of second matrix
       for (int k = 0; k < numColumns; k++) {
         int indexFirst = c*numColumns+k
         int indexSecond = k*numColumns+d
         sum = sum + matrix_a[indexFirst]*matrix_b[indexSecond]
       }
       int indexThird = c*numColumns+d
       multiply[indexThird] = sum
       sum = 0
     }
   }
   return multiply
  }
  dec[] matrix_sub(dec matrix_a[], dec matrix_b[]){
    dec subtraction[100]
    for (int c = 0; c < numColumns; c++) {
     for (int d = 0; d < numColumns; d++) {
         int index = c*numColumns+d
         subtraction[index] = matrix_a[index]-matrix_b[index]
       }
   }
   return subtraction
  }
  dec[] matrix_transpose (dec matrix[]){
    dec transpose[100]
    for (int c = 0; c < numColumns; c++) {
      for (int d = 0; d < numColumns; d++){
        int index = c*numColumns+d
        int indexTranspose = d*numColumns+c
         transpose[indexTranspose] = matrix[index]
       }
      }
      return transpose
    }
}
